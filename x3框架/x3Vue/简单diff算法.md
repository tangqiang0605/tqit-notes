## 暴力算法
对一棵树进行增删查改的复杂度都是 O(n)。

如果我们要自己实现一个暴力的 diff 算法，需要以下几步：
1. 遍历旧树，找到旧节点，判断是增删还是改。复杂度 O (m)，m 是旧虚拟树节点数。
2. 执行增删改操作，复杂度 O(l)，l 是真实 dom 的节点数。
3. 以上是一个新节点的过程，如果有 n 个新节点，就是 O(n)。
4. 总的来说，就是 O (l\*m\*n)。

## 对谁操作
1. 根据真实 dom 生成虚拟 dom 树。
2. 有更新时，会得到新的虚拟节点。
3. 将目标新旧虚拟节点进行对比，有不一样的直接修改在真实 dom 上。
4. 最后在虚拟 dom 树上用新节点替换旧节点的值。

## 优化查操作
如果虚拟 dom 存储了对应的 dom 节点，就不用去遍历真实 dom 树，复杂度为 O(1)。

遍历时只在同层进行遍历，找到差异时再去遍历下一层，不用去遍历找某一节点，而是直接指定某一层，复杂度为 O (1)。

最后，一层有 n 个节点需要遍历，复杂度是 O (n)。总体的复杂度为 O (n)。

## 优化增删操作
能够正常增删还不够，假设我们有元素 ABC，新的虚拟节点为 BCA，那么需要把 A 改成 B，B 改成 C，C 改成 A，这个过程中，把旧的 A 销毁，创建 B 放进去，把旧的 B 销毁，创建 C 进去，把旧的 C 销毁，创建新的 A 放进去。显然，还有很大的优化空间：为什么我们不直接把已有的元素拿来用呢？

diff 算法可以做到元素复用。

我们如何识别是不是同一个元素？
1. 全量对比。对比两个虚拟节点对象的所有属性，效率低。
2. 特殊标记。对比虚拟节点的唯一标识，比如 key。当 key 相同，就可以认为是同一个虚拟节点。这里不要把虚拟节点认为是完全静态的东西，它们是动态的！我们可以看成是一个维护自己动态 props 和 state 的对象。

## diff 流程
### patch
1. 一些事件触发了发布者的 setter。
2. setter 调用 Dep. notify 通知所有订阅者 Watcher。
3. Watcher 会生成一个新 Vnode，并使用 patch 进行 oldVnode 和 newVnode 对比和修正真实 dom。
4. patch 第一步：判断是不是值得去复用（通过 key、tag 以及一些特殊条件）如果不是，直接修改 dom（根据 newVnode 生成真实 dom，替换掉位置），并替换 oldVnode。
5. 如果值得复用，调用 patchVnode。

### patchVnode

## 简单 diff 算法
我们对暴力算法进行改进，只对比每一层的差异。并且，给每个节点新增一个 key 值，类似 css 选择器中给元素人为添加一个 id，用来标识一个节点。如果 key 相同，就是同一节点。

同层遍历：
1. 我们将树的每一层的元素合起来看成是一个数组。
2. 左边的元素其实有个 nextSibing 指针指向同层它右边的节点。

准备 diff：
1. 我们准备三个数组 old、new、result，分别存储旧节点数某一层的节点，新节点树对应层次的节点，以及 diff 的结果。
2. 使用 lastIndex 来记录上一个被找到的节点，用来把新找到的节点放在它后面。lastIndex 初始值为 0。

开始 diff：
1. 获取new数组的第一个元素，遍历old数组的所有元素，找到相同 key 的元素。
2. 如果没找到，说明增加了一个新节点。往 result 数组对应位置插入这个新元素。
3. 如果找到了，执行 patch 算法，会去检查这个新节点的下一层节点，然后移动这个节点。
4. 移动节点前，判断在 old 的位置是否大于上一个节点在 old 的位置（也就是 lastIndex），如果大于，则不用处理。如果小于，则移动到正确的位置（在 result 上）。因为小于就说明节点在前面，应该放在正确位置。而在后面，则说明 new 数组还没有处理的对应的 old 节点还在前面，所以不需要处理，等到 new 处理后（后移靠前元素），后面的数组也就到前面来了。
5. 移动后用 lastIndex 记录下 old 节点原来的数组的位置。

实例：
1. old：ABCD，new：DEABC，result：\[ \]
2. 开始遍历 new 数组。
3. 检查 D，发现 D 存在 old 中，且在后面，不需处理。result: D
5. 检查 E，发现不存在, 插入 result 中。result=DE。
6. 检查 A，发现存在，而且上一次存在的 D 位置是 3，A 是 0 小于 lastIndex（3），所以要移动到当前 new 位置。result=DEA。
7. 检查 B，lastIndex 是 0，B 是 1，不移动。result=DEAB。
8. 检查 C，和 B 类似，不移动。result=DEABC。

现在可以把辅助的 result 拿开，直接在虚拟树上面操作：
1. old：ABCD，new：DEABC
2. tree：ABCD
3. tree：ABCDE
4. tree：BCDEA
5. tree：CDEAB
6. tree：DEABC
这是真正的移动。具体可以看底层代码。

## 双端移动
上面实例中，只用一端移动，会导致很多次移动，使用双端可以避免。

双端移动要点：
1. 在 new 数组上多加一个尾指针。当尾指针和首指针擦肩而过时，遍历结束。
2. old 也有两个指针。每次对比的顺序是首指针和首指针，old 首指针和 new 尾指针，old 尾指针和 new 首指针，尾指针和尾指针，
3. 比对成功时，对应的指针向中间移动。

比对结果：
1. 可复用，移动。
2. 无可复用，就遍历就数组查找，找到了就移动，没找到就插入。