模块化的出现是为了解决 JavaScript 文件引入问题。在 html 中，需要按列表引入。而模块化支持模块依赖树结构，让模块之间的依赖关系更加清晰和易于管理。

## commonjs
commonjs 的包一般用于提供非 Web 的 API（nodejs 的模块）。使用 require 和 exports 的导入导出语法。commonjs 是同步加载的，所以主要用于服务端。因为模块都在本地硬盘，所以加载比较快，而且下面的操作也需要加载才执行。而浏览器的模块肯定是不在本地，而是从另一台主机获取，由于网络 IO 的特性（时间相比较长，协议不可靠），为了防止阻塞，必须使用异步。

引用模块的模块称父模块，被引用的模块称为子模块（依赖树上的子节点）。

1. 引入的是子模块的值拷贝（导出对象），后续执行中，子模块变化不会影响该值。

## AMD
requireJS 规范。
依赖前置：所有依赖都加载，速度快但是浪费资源（可能加载了用不到的模块）。
```
define(['./a','./b','./c'],cb)
```

## CMD
seajs 规范。
依赖就近：使用时才加载，速度慢性能差。
```
define(function(require,exports,module){
	var a=require('./a');
})
```

## ESM
引用：js 引擎静态解析时不会直接导入，而是生产一个只读引用，执行时才加载。

每次到了需要的时候才到模块中取值，模块的变化会影响这个值。
