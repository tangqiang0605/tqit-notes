## 基本过程
1. 解析文档。将文档解析为 dom 树。将嵌套转为树状，方便增删管理元素。
2. 在遇到 link：css 后开始下载 css，在解析完成 dom 树后，生成 cssom 规则树。
3. 根据 dom 树和 cssom 规则树构建渲染树（不插入不可见元素）。
4. 布局：如果需要重新计算布局，就是回流。
5. 绘制（paint），如果需要改变颜色等，就是重绘。

为了更好的用户体验，渲染引擎会尽早显示画面（比如图片加载的慢）。

### 预解析
当解析 js 时，开辟新的线程去下载后面需要下载的内容。

### css 阻塞
一般来说，css 只下载，并在文档解析后解析。但是，如果 js 中请求未解析的 css 样式，会暂停 js 和文档的解析，优先解析 cssom，然后再执行 js，再继续解析文档。

## 渲染优化
可以参考：[如何优化前端性能（五）：减少重绘回流 - 知乎](https://zhuanlan.zhihu.com/p/438036652)

### 引入
3. 防止 JavaScript 阻塞解析进程。
4. css 引入。外部使用 link，如果 css 少，直接内联。

### 样式
1. 避免深层、复杂选择器。
2. 避免 css 表达式，计算频率很高。
3. 图片设置尺寸。
4. 不使用 table 布局。
5. 尽量使用 css 而不是 js。

### 渲染层
1. 脱离文档流为独立渲染层，减少重绘范围。

## dom
1. 缓存 dom（用变量保存，而不是每次都要查询）
2. 减少 dom 深度和数量。
3. 批量操作 dom。innerHTML 更新。
4. 
5. 使用语义化标签
6. 操作低级 dom 元素。
2. 修改类名而不是样式。
5. 内存中操作。使用文档片段 documentFragment 批量更新。
6. 离线更新（display：none）。
7. 读写分离。将多次 dom 的读操纵、写操作放在一起，而不是读写穿插（参考渲染队列），这样它们是可以合并成一次的。如果修改后，读取，是必须重新渲染一次的。
8. 使用事件代理。减少监听对象的创建。
9. 防抖节流。
10. 及时清理。对象引用、事件监听、定时器。创建最小作用域。

## 渲染队列
浏览器针对页面的回流和重绘进行了优化，使用了**惰性渲染机制**。在不必要马上渲染的情况下，只有当队列中的操作达到一定数量或时间，才会对队列进行批处理，让多次回流重绘变为一次。