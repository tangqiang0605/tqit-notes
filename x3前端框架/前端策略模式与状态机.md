最近在完成一个仓库的出入库业务时，由于起初的流程比较简单，写了两个嵌套多层 if-else 代码的函数就完成了任务，但是在测试的过程中，偶然发现有一个 bug，不管怎么改，总是会存在状态冲突的问题，于是。花了一番心思把代码大改了一番，结果，代码不仅变得更加复杂，还多了许多奇奇怪怪的问题。无奈之下，只能求助于状态机。

虽然在出入库的过程中只维护了几个简单的状态，对于状态机来说有点大材小用了，但是它确实完全解决了各种有关状态的问题，让我对于代码的信心成倍提升，可以自信的说“这段代码没有问题”，可见状态机如此强大！

现我将使用状态机中基础认识记录下来，希望可以给更多想接触状态机的前端小伙伴们一些启发，如果我的理解有误，欢迎大家在评论区中指出，有望受教了。

在正式介绍状态机之前，我们先简单了解两种相关的设计模式：策略模式和状态模式。
## 策略模式
设计模式之一。简单的说，就是对象的不同方法对应不同的行为。并且这些行为是互斥的，只能选择其中一个。在实现的时候，我们往往使用一个变量来存储将要调用的方法名。因为变量只能存一个值，所以使用一个变量一次只能调用一个方法。调用对象的方法时，有所选择，有所取舍，这就是所谓“策略”。
```
const obj={
	isSun:()=>console.log('sunday')
	isRain:()=>console.log('rainday')
}
const weather='isSun'
obj[weather]
```

使用策略模式可以避免多重条件选择语句，增强代码的维护性。
```
const work='老师'
const sex='女'

// 不使用策略模式
if (work == '老师') {
  if (sex == '男') {
    console.log('男老师')
  }
  if (sex == '女') {
    console.log('女老师')
  }
} else if (work == '医生') {
  if (sex == '男') {
    console.log('男医生')
  }
  if (sex == '女') {
    console.log('女医生')
  }
}

// 使用策略模式
const obj = {
  '老师': {
    '男': ()=>console.log('男老师'),
    '女': ()=>console.log('女老师')
  },
  '医生': {
    '男': ()=>console.log('男医生'),
    '女': ()=>console.log('女医生')
  }
}
obj[work][sex]
```

局限性：从上面代码也可以看出，策略对象不能完全替代 if-else。当判断条件不是简单的等于，而是小于、大于以及复杂条件时，策略对象将无法完成工作。在协同工作方面，通过策略模式写出的代码会比 if-else 更难理解，需要合作者有更高的代码水平。

策略模式：redux-toolkit

## 状态模式
状态模式和策略模式非常相像。都是通过限制对象的行为来达成某种目的。在策略模式的基础上，状态对象的行为还受对象内部的状态影响。当一个对象内部的某个状态发生改变时，其行为也会不同。
```
class Dog {
  constructor(state) {
    this.isHungry = state;
  }
  giveFood() {
    if (this.isHungry) {
      console.log('eat')
    } else {
      console.log('run away')
    }
  }
  setHungry(state) {
    console.log('set hungry state')
    this.isHungry = state;
  }
}

const dog = new Dog(false);
dog.giveFood()
dog.setHungry(true)
dog.giveFood()
```

状态模式最典型的实例就是有限状态机，它保证了程序在特定状态做出特定行为，相比于 if-else，它的可维护性更高。在游戏开发中，经常会使用到有限状态机，比如，人物在行走状态下点击攻击，角色会往前攻击，在滞空状态（跳跃起来）下点击攻击，角色可能会向下突刺。

## 有限状态机
有限状态机通过声明状态对应的一种或一组行为，来保证程序按照既定的逻辑行为运行。

这里我选用 xstate 来实现状态机，主要原因是我上网搜的时候第一个
