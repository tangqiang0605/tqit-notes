Reflect.has()方法用于检查一个对象是否拥有某个属性中。如果该属性存在于原型链中，也会返回 true。
```
Reflect.has(obj,key)
```

in 的作用和 Reflect.has()方法相同。
```
console.log(key in obj)
```

## Object. prototype. hasOwnProperty
obj.hasOwnProperty()方法返回一个布尔值，指示对象是否具有指定具有指定的属性（而不是继承它）。它可以正确地区分对象本身的属性和其原型的属性。但是这种判断方法也有问题，那就是如果对象是使用 Object.create(null)方式创建的，那么就不能使用 hasOwnProperty()方法进行判断了。
```
obj.hasOwnProperty(key)
```

如果将 hasOwnProperty()作为对象的一个属性 (重新赋值），这样也无法使用 hasOwnProperty()方法判断属性是否来自原型链了。可使用下面的方法避免：
```
Object.prototype.hasOwnProperty.call(obj,key)
({}).hasOwnPerperty.call(obj,key)
```
这也是为什么总是用原型链的方法而不用对象方法再追溯到原型链的原因之一。

## Object. hasOwn
Object.hasOwn()与 Object.hasOwnPeoperty()的区别：因为实例的 hasOwnProperty 方法是从 Object 的原型上拿到的，如果使用 Object.create(null)的方式创建一个对象那么就拿不到 hasOwnProperty 这个方法，而 hasOwn 作为 Object 的静态方法是可以直接通过 Object 来进行调用。ES2022提出的, 不过兼容性友好。