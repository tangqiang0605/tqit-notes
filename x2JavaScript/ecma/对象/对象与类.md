## 属性描述符
每个属性都有一个与之关联的属性描述符，描述了属性的各种特性。可以使用 Object. getOwnPropertyDescriptor () 方法获取属性的描述符。
```
{ value: 'John', writable: true, enumerable: true, configurable: true }
```
对象属性具有值、可枚举、可覆写（freeze）、可配置属性。可通过 Object. defineProperty 设置。

> 使用 Object.getOwnPropertyDescriptor 查看，会发现 window.document 的 configurable 属性为 false（不可配置的）。
## 属性枚举
1. for... in... 遍历可枚举属性
1. Object. keys：返回自身可枚举属性的数组
2. Object. values：自身可枚举属性值的数组
3. Object. entries：自身可枚举属性键值对数组
4. Reflect. ownKeys：自身所有属性。
3. Object. getOwnPropertyNames
4. Object. getOwnPropertySymbols

## Object 静态方法
通过 Object. xxx (obj)调用
1. Object. assign：复制到目标对象
2. Object. freeze：是对象属性不可修改

## Object. prototype 方法
可通过 obj. xxx 调用
1. hasOwnPropetry (key) 是否为自身属性


-   在 JS 中执行，this 指向当前模块，在命令行中执行，this 指向 global
## 基础
对象中的属性
```js
{
	title:'the title'，
}
```

对象中的方法
```js
// 1.与属性统一，将fn作为属性值
{
	getTitle：fn，
}
// 2.对象中的方法：新写法，无需function关键字
{
	getTitle(){}
}
```

## 类
1. 对象可以通过构造函数产生、或者使用类（es 6+）。
2. class 没有类型提升。
3. 类名本质上也是一个构造函数。

关键词知识点：new。constructor。this。method ()。extends。supper ()。static。get 和 set。

最简单的类
```js title="最简单的类"
class ClassName(){}
const myClass = new ClassName();
```

构造函数
- 构造函数不可重写。
- 如果有继承，构造函数中必须包含 super 函数，位置任意。
- 如果不定义构造方法，JavaScript 会自动添加一个空的构造方法。
```js
class Runoob { constructor(name, url) { this.name = name; this.url = url; } }
let site = new Runoob("菜鸟教程", "https://www.runoob.com");
```

方法
```
class ClassName(){
	method_1() { ... } 
	method_2() { ... } 
	method_3() { ... }
}
```

静态方法 static
对象不能调用静态方法、属性。
```
class ClassName(){
	static method_1() { ... } 
}
ClassName.method_1();
```

继承 extends
多继承：用逗号隔开
继承代表了 **is a** 关系。子是父。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。
子可以使用父的方法，`this. theMethodFromFather ()`
在 JavaScript 中，几乎所有的对象都是 Object 类型的实例，它们都会从 `Object.prototype` 继承属性和方法。

get 属性名。属性名要加前缀下划线。
getter/setter 方法的名称不能与属性的名称相同，在本例中属名为 sitename。
很多开发者在属性名称前使用下划线字符 _ 将 getter/setter 与实际属性分开：
以下实例使用下划线 _ 来设置属性，并创建对应的 getter/setter 方法：

实例
```
class Runoob { 
	constructor (name) { this._sitename = name; } 
	get sitename () { return this._sitename; } 
	set sitename (x) { this._sitename = x; } 
}
```

### 提升
函数声明和类声明之间的一个重要区别在于, 函数声明会提升，类声明不会。
你首先需要声明你的类，然后再访问它，否则类似以下的代码将抛出 ReferenceError：

使用函数来构造对象、方法：
```js
function person(firstname,lastname,age,eyecolor) { 
	this.firstname=firstname; 
	this.lastname=lastname; 
	
    this.changeName=changeName;
    function changeName(name)
    {
        this.lastname=name;
    }
}
```

### 遍历
JavaScript for... in 语句循环遍历对象的属性。
for (variable in object)
{
    执行的代码……
}

对象是可变的，它们是通过引用来传递的。
以下实例的 person 对象不会创建副本：
var x = person;  // 不会创建 person 的副本，是引用
如果修改 x ，person 的属性也会改变

### 类表达式（没什么用）

类表达式是定义类的另一种方法。类表达式可以命名或不命名。命名类表达式的名称是该类体的局部名称。

实例
```js
// 未命名/匿名类
let Runoob = class {
  constructor(name, url) {
    this.name = name;
    this.url = url;
  }
};
console.log(Runoob.name);
// output: "Runoob"

// 命名类
let Runoob = class Runoob2 {
  constructor(name, url) {
    this.name = name;
    this.url = url;
  }
}; console.log(Runoob.name);
// 输出: "Runoob2"
```

### 原型链
如果我定义了一个类 Student，该类继承自 Person。new 一个 Student 对象，该对象只包含 constructor 方法中定义的属性，类中的所有方法都会放到对象的 `__proto__` 中，因为 isA （Student 继承自 Person，故 Student is Person）的关系，这个 proto 是 Person。同理，Student（即 Person）的 proto 是 Object（因为 Person is Object）。

如果不使用 constructor，会自动调用 super 让 new 出来的对象具有属性。如果使用 constructor，必须手动调用 super 继承父类的所有属性。

super 需要在定义 this 属性前调用。



