垃圾回收（Garbage Collection，简称 GC）。垃圾收集器会周期性地（或在特定触发条件下）运行，找出不再使用的变量，然后释放其占用的内存。

## JavaScript 的内存生命周期
这个过程通常分为三个阶段：

分配内存：当声明变量、添加属性、或者调用函数等操作时，JavaScript 引擎会分配内存来存储值。例如，当你写 let a = 1 时，JavaScript 引擎会为变量 a 分配一块内存来存储值1。

使用内存：在分配了内存之后，我们可以通过读写操作来使用这块内存。例如，我们可以读取变量 a 的值，或者改变它的值。

释放内存：当内存不再被需要时（例如，变量已经离开了它的作用域），这块内存需要被释放，以便为新的内存分配做出空间。这个过程就是垃圾回收。

## 标记-清除算法
JavaScript 中最常用的垃圾回收算法。它的工作原理大致可以分为两个阶段：标记和清除。“垃圾”，它们无法从根对象访问到。

标记阶段，垃圾回收器从一组“根”（root）对象开始，遍历所有从这些根对象可达的对象。可达的对象包括直接引用的对象，以及通过其他可达对象间接引用的对象。所有可达的对象都被标记为“活动的”或“非垃圾的”。清除阶段在堆内存中回收未标记的对象。

## 引用计数算法
引用计数是另一种垃圾回收策略。这种策略的基本思想是跟踪每个对象被引用的次数。当这个引用次数变成0时，就表示没有任何地方再引用这个值了，因此该值可以被视为“垃圾”并被收集。

然而，引用计数算法有一个著名的问题，那就是循环引用。如果两个对象相互引用，即使它们没有被其他任何对象引用，它们的引用次数也不会是0，因此它们不会被回收，这会导致内存泄漏。为了解决这个问题，现代 JavaScript 引擎通常会结合使用标记-清除和引用计数两种算法。

## 优化策略
现代 JavaScript 引擎不仅实现了上述的基础垃圾回收算法，而且引入了一些优化策略，以提高垃圾回收的效率并减小对性能的影响。

###  分代收集
大部分的 JavaScript 对象在创建后很快就会死亡，而那些能活下来的对象，通常能活很久。这给了 JavaScript 引擎一个优化垃圾收集的思路。它把内存堆分为两个

区域：新生代和老生代。新生代存放的是生存时间短的对象，老生代存放的是生存时间长的对象。新生代的垃圾回收采用 Scavenge 算法，它将新生代的空间一分为二，一个为使用空间（From），一个为空闲空间（To）。新对象总是被分配到 From 空间，当 From 空间快被使用完时，就会触发垃圾回收过程。回收过程中，存活的对象将会被复制到 To 空间，同时 From 和 To 空间的角色会对调，也就是原来的 To 空间变成新的 From 空间。这个过程称为新生代的晋升策略。老生代采用了标记-清除和标记-整理算法


### 延迟清除和增量标记
延迟清除”是指，在标记-清除算法中，垃圾回收器并不是在标记完对象之后立即清除，而是将清除操作延迟到应用程序空闲时进行。
增量标记”则是将一次完整的标记过程分解为几个部分，每个部分只标记一部分对象。让出 CPU 给应用程序，然后再运行一小段时间

## 代码优化
1 解除对象引用
```
解除对象引用
当你不再需要一个对象时，应该解除对它的引用。
timer=null
```

2. 避免长生命周期的引用
长生命周期的引用（例如：全局变量或 DOM 引用）会阻止垃圾回收器回收它们所引用的对象。因此，应该尽量避免使用长生命周期的引用，或者在不再需要它们时及时解除引用。