## 原理
这是函数声明语句，是一个独立的语句。
```js
function foo(){}
```

不能在函数声明语句后添加括号。在大括号后面加圆括号不会有任何效果，除了报错，因为一，这是两个独立的语句，分开执行，二，圆括号表达式对括号内的内容进行求值，如果无值可求，则报错。
```js
function foo(){}()
```

函数调用：可以对函数表达式后加括号表示执行函数。
```js
foo()
```

可见，函数声明会把函数表达式存入函数名中（赋值）。通过函数声明获得函数表达式的操作称为函数求值。函数表达式加上括号表示执行函数。除了显式声明函数通过函数名获得函数表达式外，还可以通过其他常见的求值操作获得函数表达式。
```js
// 赋值求值
let foo=()=>{}
foo()
// 圆括号求值：将函数声明转为表达式。表达式后加括号表示执行。
(()=>{})()
// 先执行函数获得返回值，再执行运算符。
+()=>{}()
&()=>{}()
```

在获得函数声明后就立即执行的函数称为立即执行函数。w3c 推荐写法：
```js
;(funtion(){});
```

需求：当函数需要拥有私有变量时，可以通过立即函数实现，这种需求的实现方法就是 IFFE。
```js
// 立即执行函数中声明局部变量，该变量可以被return中的函数读取和使用。即return函数的私有变量。
// 立即执行得到return的函数，赋给变量作为函数表达式。
let foo=(()=>{
	let value=0;
	return ()=>++value;
})();
// 对value进行了两次运算
console.log(foo())// 1
console.log(foo())// 2
```
return 函数使用私有变量运用了闭包的思想。
```js
// 这是闭包，将value作为return函数的私有变量。
function foo(){
	let value=0;
	return ()=>++value;
}
```

## 总结
求值
1. 对普通变量求值：1+1，结果为 2
2. 对函数声明求值：const foo=()=>{}，结果为函数表达式并赋给变量 foo，函数表达式后加圆括号可以立即执行该函数。
3. 求值的方法有：圆括号、运算符、赋值等。

圆括号
1. 作用一，用于求值，且优先级高。1*(2+3)，优先求 2+3 的值。可以对函数声明进行求值。
2. 作用二，执行函数。如 plus(1,2) 。

函数
1. 可以对函数声明求值得到函数表达式。
2. 可以对函数表达式后加括号执行函数。

立即执行函数
1. 就是声明函数后就需要立即执行的函数。
2. 一般写法
```js
;(function foo(){});
```
3. 由于函数提升，所以立即执行函数在函数被提升后立即执行，在其他代码执行前优先执行（除非前面还有更早声明的立即执行函数要执行）。

闭包：利用垃圾回收机制保持对局部变量的引用。
当函数需要一个变量来保存数据时：
方法一：可以声明一个全局变量，但是该全局变量与函数代码是分割开的，而且可以被其他函数读取。
方法二：可以在函数内声明一个私有变量，但是函数执行完毕后就会被销毁。下次调用时私有变量还是初始值。
方法三：使用闭包，函数可以拥有私有变量，且函数执行完毕后不会被销毁，下次执行函数时，变量的值。
思考：可以使用 this 吗？可以。但没有闭包方便且不满足需求：我们需要的是函数的私有变量，而不是对象的私有变量（即使函数也是对象的一种，但二者终究是不一样的）。
```js
// this实现
funtion foo(){
	this.value=0;
	this.add=()=>++value
}
const obj=foo();
console.log(obj.add());// 1
console.log(obj.add());// 2

// 闭包
const foo=(()=>{
	let value=0;
	return ()=>++value;
});
console.log(foo());
console.log(foo())
```

函数柯里化
在闭包中我们 return 了一个函数，在函数柯里化中我们也 return 了一个函数。
函数的返回值可以是任何 js 允许的值，包括函数（函数返回函数）。闭包和函数柯里化是**返回函数的函数**中的特例。
闭包：一般是一个返回函数的函数。目的是实现函数私有变量。在 return 的函数中，是对函数的局部变量进行使用。
函数柯里化：一个返回函数的函数。目的是对函数进行装饰（aop 思想）。在 return 的函数中，是对参数进行使用，因为函数参数也是一种局部变量，所以柯里化函数也是一种特殊的闭包。
函数柯里化可以实现兼容性检测并返回一个当下环境支持的函数，在不同环境下保证我们使用的是同一个函数而拥有不同的兼容性 api。

闭包原理：函数作用域链与局部变量自动回收机制。
函数作用域链：函数对外部变量的使用原则。函数找不到里面的变量，就会向外查找。函数里的变量被使用，函数执行结束后仍不会被销毁。一般来说，函数内的变量只被本函数引用，函数执行结束=>函数取消对局部变量的引用=>局部变量没有被引用=>局部变量被销毁。而闭包中，局部变量不被本函数引用，但仍被 return 函数引用，不会被自动回收。

闭包例子（闭包也可以不是函数），闭包是指对外部局部变量的引用以保持外部的局部变量不被销毁。
![[Pasted image 20230305112458.png]]
![[Pasted image 20230305112710.png]]

作用域链与执行上下文
![[Pasted image 20230305111920.png]]

提升
对于变量，提升的是声明，而不是赋值，也就是说，只要变量有声明，即使提前打印，也不会报错，而是打印空。
函数的提升比变量优先。
思考：
1. 提升函数 2. 提升变量 3. 代码执行


this 四种绑定
1. new 绑定。函数中 this 赋值挂载数值。
2. 默认 window。
3. call、bind、apply