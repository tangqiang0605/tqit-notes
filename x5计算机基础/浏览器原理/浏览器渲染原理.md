分为浏览器进程和渲染进程。了解渲染原理，可以更好地对网页代码进行优化。

## 浏览器进程
### 浏览器历史 
按时间顺序：IE（trident）、firefox 火狐（gecko）、safari 苹果（webkit）、chrome 谷歌（blink）、edge（blink）。
括号后为浏览器内核。blink 是基于 webkit 改造优化的。因为有了ie、safari、chrome 对内核的开源，才有如今欣欣向荣的浏览器世界。

### 浏览器结构
1. 用户界面
2. 浏览器引擎：传递数据（给用户界面与渲染引擎）、数据管理等。
3. 渲染引擎：浏览器内核，浏览器最重要的部分。包含网络请求、js 解析器（v8）等部分。

### 进程与线程
**进程**是计算机分配给应用程序的资源，用来运行应用程序。进程相对独立，通过通信管道 ipc 传递进程之间的信息（安全）。一个应用程序可以有多个进程，一个进程可以有多个**线程**。线程之间可以直接共享数据（不安全）。

早期的浏览器只有一个进程。因此存在以下问题：1. 一旦进程卡死，浏览器无法执行其他任务，2. js 文件可以访问浏览器所有数据，不安全。3. 相比多进程，运行效率低。现代的浏览器是多进程应用。包括缓存进程、网络进程、插件进程、GPU 进程，以及最重要的**浏览器进程**，**渲染器进程**（渲染器进程由浏览器进程创建，可以存在多个渲染器进程）。

### 进程模型
默认情况下，chrome 浏览器进程**为用户访问的每一个网站创建一个渲染器进程**。每个标签页（tag）里的每个站点都是相互不影响的（进程隔离）。
除此之外，chrome 还有其他进程模型：1. 同一站点使用同一进程。2. 一个标签页里的所有站点使用同一个进程。3. 浏览器引擎和渲染引擎共用一个进程。

### 浏览器进程
现代浏览器有很多进程，最重要的就是浏览器进程和渲染进程。

浏览器进程的工作：搜索url => dns 解析 => 获得 ip => 黑名单 => 访问 ip => 获得数据 => 渲染。
当用户输入内容进行搜索时，浏览器进程启动，调用 ui 线程。ui 线程根据搜索内容进行访问：如果是关键词，则 ui 线程丢给搜索引擎；如果是 url，访问网络线程，网络线程请求 dns 进行域名解析，dns 将域名转化为可直接访问的公网 ip 地址返回给网络线程，网络线程通过黑名单（safebrowsing，谷歌的安全黑名单系统）检查是否为恶意站点（可以坚持访问），访问网站获得网站的页面文件（html），ui 线程创建渲染器进程，通过 ipc 将数据（html 文件）发给渲染器进程进行页面的渲染。

以上操作均在浏览器进程中操作。上述过程中，浏览器进程创建了浏览器主线程、ui 线程、网络线程、渲染进程。最后浏览器进程将数据传给渲染器进程。

补充：以上浏览器与服务器初次建立连接（访问 ip 获得数据）时，如果是 http 协议，浏览器所在主机会与服务器进行 tcp 三次握手（如果是 https，还会多三步 tls 握手）建立链接。然后发送请求、获得响应。

## 渲染进程
浏览器渲染页面，是一帧一帧进行渲染的，每一帧称为**浏览器帧**。浏览器的渲染过程，可以从线程视角、帧视角和事件循环视角理解。**渲染进程**包括**渲染器主线程**、**合成器线程**、**栅格化线程**。

打开 [Janky Animation (googlechrome.github.io)](https://googlechrome.github.io/devtools-samples/jank/)。在浏览器的调试模式中（F12），打开性能 （performance）录制 （record）然后在 main 里可以看到：
![[Pasted image 20230310195606.png]]

在 chrome 进程模型中，我们知道，浏览器会为一个标签页里的一个网站创建一个渲染进程。这个渲染进程不断对浏览器进程通过 ipc 管道传送来的数据进行渲染。在图中我们可以看到，渲染是一帧一帧执行的（这里一共显示了三帧）。每帧渲染结束，渲染主线程又重新开始，渲染新的浏览器帧，这个循环又称**事件循环（event loop）**。

### 主线程开始、帧开始
渲染进程的渲染主进程开始新的事件循环周期，帧也就开始绘制了。只有页面改变时，帧的内容才会发生改变。如果页面的元素不变，仍会执行事件循环，只不过不会渲染新帧出来，而是读取上一帧的内容。即，移动页面或触发重排重绘，会生成新帧。如果没有新帧，则使用上一次使用的帧。

#### 执行宏微任务、rAF
首先执行宏任务：从 task 队列中取出第一个并执行。事件循环可能存在多个任务队列，但主要还是分配给鼠键事件 [input events]，用来处理用户的交互，进而可能导致其他 task 宏任务可能被延后。执行宏任务之后，清空微任务队列。

不管是宏任务还是微任务，这个阶段跑的是浏览器的 js 源码和开发者编写的 js 代码（除非这个时候开发者的 js 代码还没有被加载进来），开发者的 js 代码，一般都会进行 dom 操作。如果是浏览器使用者第一次打开网站，获得一个网页，这个时候网页还没有被解析，在第一帧里，是没有开发者的 js 代码可以执行的。而第一帧解析 html 时就会执行 html 里的 js 代码，第二帧的时候如果还有 js 代码可以执行（处理用户交互），就会执行宏任务。

这个时候也会执行 rAF, rAF 是一个函数，什么时候执行，看它被放在宏任务还是微任务的哪个地方，作为普通代码执行。

#### 渲染机会
每一轮事件循环不一定伴随着渲染。是否需要渲染，要根据屏幕刷新率、页面性能、[[页面可见]] 来决定，也就是**渲染机会**（rendering opportunity ）来决定，当然，如果渲染不能带来页面上的变化并且没有 rAF 回调，自然也跳过渲染过程。另外，有时候浏览器希望两次定时器任务是合并的，中间只有微任务而不会穿插屏幕渲染，这种现象暂称为定时器合并。

#### 定时器合并
定时器宏任务可能会直接跳过渲染。这个行为具有相对的不可预测性（由根据系统的性能情况等多个因素构成的渲染机会）。按照一些常规的理解来说，宏任务之间理应穿插渲染，而定时器任务就是一个典型的宏任务。
```javascript
setTimeout(() => {
  console.log("sto")
  requestAnimationFrame(() => console.log("rAF"))
})
setTimeout(() => {
  console.log("sto")
  requestAnimationFrame(() => console.log("rAF"))
})

queueMicrotask(() => console.log("mic"))
queueMicrotask(() => console.log("mic"))
直觉上，顺序应该是：mic、mic、sto、rAF、sto、rAF。
实际上，浏览器会合并这两个定时器任务：mic、mic、sto、sto、rAF、rAF。因为这两个定时器的相差时间少于一帧。
```

### 解析 html
在执行完宏任务和微任务后，会依次执行 resize、scroll、rAF 的回调，之后，渲染主线程开始解析 html。

#### 主线程解析 html 与预扫描线程下载
浏览器进程通过 ipc 通道将 html 文件传给渲染器进程，这个文件是字节格式的，需要进行解析。在渲染主线程的解析器中，会将字节 html 转化为文本 html，再进行令牌化（tokeniser），然后将匹配的令牌内容生成节点对象。这个时候，内存里就存在很多个随意放置的节点对象，为了对这些对象进行方便的管理，解析器把这些对象按一定规则串联起来，构成了节点对象树（dom 树）。dom，即文档对象模型（document object model ），html 里的所有标签都是一个 dom。树可以将节点有效组织起来，方便对 dom 进行操作。

在解析 html 前，会先创建一个**预扫描线程**，扫描 html 里的标签，提前下载里面的 css、image、js 文件。所以在解析 html 的同时，文件也在下载，二者是异步的。渲染主线程解析到 link 和 script 标签时，会对已经下载好的内容进行解析和构建，如果还在下载，主线程会等待下载完成。

#### 构建 cssom 树与样式计算
cssom，即层叠样式表对象模型（Cascading Style Sheets Object Model）。在解析 html 的过程中，如果遇到 css 文件，会暂停 dom 树的构建，转而开始解析 css，形成 cssom 树。构建 cssom 树完成后，继续构建 dom 树。
解析 css 时，为了方便样式覆盖，不会中断构建，如果中断了，层级关系又要重新分析，相当于又重头再来，前面的部分 css 分析也就没有意义了。而 dom 树则是在布局和绘制时决定层叠位置（在此之前只有父子关系）。所以，**html 的解析（dom 树的构建）可以中断，而 css 的解析是不能中断的。**

#### 执行 js 与 js 的位置
html 中可能包含 js 代码（不管是外联的还是内联的）。js 代码一般是对 dom 或者 cssom 进行操作，所以往往要放在 dom 树和 cssom 树构建完成的后面，但它也可以放在 dom 树构建的过程中，这时候，解析 html 遇到 js 代码，也会停止 dom 树的构建，执行 js 代码。 js 代码只能对前面的 dom、cssom 进行操作，而无法对后面未添加进树的节点进行操作。

**js 应该至少等 css 解析完成再执行。** 解析 css 会阻塞主线程，执行 css、构建 js 任务是同步加入主线程的，不管 js 什么时候执行，我们都应该安排其在 css 后。

基于这个阻塞限制（停止 dom 树的构建），我们要把 script 放在正确位置：放在需要操作的 dom 后（如果放在最后，等同于 defer）；async（构建 dom 树的同时执行 js）；defer（完成 dom 树、布局绘制后执行 js）。

### 渲染过程
![[Pasted image 20230312001208.png]]
浏览器执行了 js 代码处理完用户的交互、解析了 html，接下来就是生成渲染树进行布局和渲染。

#### 样式计算与渲染树
完成 html 的解析后，浏览器根据 dom 树和 cssom 树，计算出样式值，这个过程称为**样式计算（recalculate style）**，然后根据计算结果，合成渲染树（render tree），只包含显示的节点, 这一过程称为attachment。节点是否显示，关系到 dom (伪类有 content 才显示、meta、link 标签)，也关系到 cssom（display 不为 none），需要将两者匹配起来，然后进行判断，再加入渲染树。**渲染树的任务就是匹配和筛选节点。**

#### 布局与绘制
浏览器根据渲染树上节点的大小位置进行**布局（layout）**，如果有两个节点的位置发生重叠，浏览器会根据层级关系（顺序绘制）创建绘制记录表，后面渲染时按照顺序绘制即可，这个过程就是**update layout tree**（用于确认层级）。根据节点的 only paint 属性对节点进行**绘制（paint）**。布局和绘制可能会进行多次。绘制后还会执行 resizeObserver 回调等操作。完成布局和绘制后，渲染主线程将这些信息传递给**合成器线程**。**如果布局和绘制意外地触发了 rAF，即所谓的强制同步布局，通常对性能不利。**

#### 重排、重绘与回流reflow
页面的生命周期中，至少渲染一次。用户交互的过程中，还可能产生重排和重绘。重排也叫回流（但更具体的应该体现在图片的加载上）。修改元素属性（比如，图片加载完成后根据图片大小重新设置图片元素的宽高），都会重新进行样式计算，如果涉及重新布局，会经历样式计算、布局、绘制，以及后面的合成器线程，这是重排。如果只是修改颜色等 paint only 属性，不会触发布局，但仍会占用主线程并调用合成器线程，这是重绘。**重排和重绘都会占用主线程和合成器线程。**

js 修改 dom，触发样式计算：
1. 如果修改位置大小，经历 layout、paint，重排，占用主线程。
2. 如果修改 paint only 属性，经历 paint，重绘，占用主线程。
3. 修改样式但不经历 layout、paint，直接进入主线程。

不要使用 table 布局，因为一点小改动就会造成整个 table 重新布局。

#### 渲染主线程优化
1. 避免操作 dom 元素的同时还运行大量代码。
js 也在渲染器主线程运行，布局和绘制后如果还有 js 在运行（比如 resizeObserver 回调），会导致新帧绘制请求被阻塞 （因为主线程上的 js 还在跑），没有按时渲染，而是 js 执行后才渲染，会产生延迟或掉帧效果。js 改变元素属性，产生重排或重绘，但如果 js 很长还没有跑完，这个渲染会延迟。

要从根本上避免执行 js 的 dom 操作时还执行大量其他的代码，避免重绘和重排。使用 rAF 和 rIC 进行调度。将 js 任务作为回调放入该函数中，该函数在每帧时间结束时暂停 js 执行（即最开始的布局后，执行 js，如果该帧结束，js 暂停，绘制下一帧，如果没有绘制任务，js 继续执行，直到该帧结束。这里的帧可以理解为时间）

栅格化不占用主线程，当主线程被 js 使用时，我们的 css 如果只是使用合成器线程，是不会受影响的。具体就是使用只在合成器和栅格线程执行的 css 属性如 transform（不需要经过布局绘制）

2. 尽量不要占用渲染主线程，利用好可以同时执行的合成器线程，尽可能让帧不经过重排重绘：
-   坚持使用 transform 和 opacity 属性更改来实现动画。  
-   使用 will-change 或 `translateZ` 提升移动的元素。

3. 样式集中改变
更改类名比修改样式好

4. 分离读写。读取 dom 元素和操作 dom 元素分开写。

4. dom 离线。
	巧用 displaynone（两次）
	documentFragment（一次）
	复制节点修改然后替换掉（一次）
	脱离文档流

动画优化
1. 应用在脱离文档流的元素上



### 合成器线程与栅格化线程
布局和绘制后，渲染主线程将这些信息传给合成器线程。合成器通过**合成**（多图层栅格化）生成合成帧。栅格化过程中，大图层分为多个图块给栅格化线程。栅格化线程栅格图块并存储在 GPU 内存中，然后返回图块信息给合成器线程。合成器根据这些信息生成合成器帧并通过 ipc 提交给浏览器进程。浏览器的线程将合成帧交给 gpu 获得 gpu 内存的内容并渲染显示。

栅格化：在视图区域显示部分页面内容。早期只有一个图层。后面采用了合成技术。合成（composite，一种栅格化方案），将页面各部分分成多图层进行栅格化，分配给栅格化线程，最后再由合成器线程处理。

浏览器主进程的 ui 线程获得响应数据，传给渲染器进程。渲染器主线程解析 dom 树、计算 css、生成布局和绘制顺序，将布局和绘制丢给合成器线程。合成器分层分块丢给栅格线程并收集返回的信息合成合成器帧传回浏览器进程。浏览器传到 gpu 渲染显示。

### 帧空闲
绘制完成后，距离帧结束可能还有一段事件。一般来说我们一帧的时间是 16.66ms 左右（保持 60fps），如果这个时候还有剩余时间，浏览器会执行 rIC 中的回调。

## 相关概念
微任务：一般认为执行创建 promise 时接受的回调。但也可以认为包括 resize、scroll 的派发、rAF 和 rIC。

页面可见：当页面被最小化或者被切换成后台标签页时，页面为不可见，浏览器会触发一个 [visibilitychange] 事件, 并设置 document. hidden 属性为 true；切换到显示状态时，页面为可见，同样触发一个 visibilitychange 事件，设置 document. hidden 属性为 false。页面不可见时，eventloop 可能不会执行渲染阶段[rendering opportunity]，进而不执行 rAF（而 setTimerout 仍会执行动画，占用资源）。

参考：
推荐：[看了就会的浏览器帧原理 (qq.com)](https://mp.weixin.qq.com/s/Q4MBBFhc-ONrpCYWhow3uw)
[深入解析你不知道的 EventLoop 和浏览器渲染、帧动画、空闲回调（动图演示） - 掘金 (juejin.cn)](https://juejin.cn/post/6844904165462769678)